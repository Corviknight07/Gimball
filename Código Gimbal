#include <Wire.h>
#include <Servo.h>

#define MPU 0x68

Servo ServoRoll;
Servo ServoPitch;

Servo ServoYaw;

int16_t AcX, AcY, AcZ;
int16_t Tmp;
int16_t GyX, GyY, GyZ;

float gyroX_off = 0, gyroY_off = 0, gyroZ_off = 0;

float Roll = 0, Pitch = 0;

float Yaw = 0;

unsigned long lastMicros = 0;

float alpha = 0.96;

float Kp = 2.3;
float Ki = 0.0;
float Kd = 3.5;

float errR_prev = 0, errP_prev = 0;

float errY_prev = 0;
float intR = 0, intP = 0;

float intY = 0;


int SERVO_MIN = 20;
int SERVO_MAX = 160;
int SERVO_CENTER = 90;

float I_MAX = 100.0;
float I_MIN = -100.0;

float DER_MAX = 500.0;
float DT_MIN = 1e-4;


void readMPU() {
  Wire.beginTransmission(MPU);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU, 14, true);

  AcX = (Wire.read() << 8) | Wire.read();
  AcY = (Wire.read() << 8) | Wire.read();
  AcZ = (Wire.read() << 8) | Wire.read();

  Tmp = (Wire.read() << 8) | Wire.read();

  GyX = (Wire.read() << 8) | Wire.read();
  GyY = (Wire.read() << 8) | Wire.read();
  GyZ = (Wire.read() << 8) | Wire.read();
}

void computeAngles(float dt) {

  float accelRoll  = atan2((float)AcY, (float)AcZ) * 180.0 / PI;
  float accelPitch = atan2(-(float)AcX, sqrt((float)AcY * (float)AcY + (float)AcZ * (float)AcZ)) * 180.0 / PI;


  float gyroRoll  = ((float)GyX - gyroX_off) / 131.0;
  float gyroPitch = ((float)GyY - gyroY_off) / 131.0;

  float gyroYaw   = ((float)GyZ - gyroZ_off) / 131.0;


  Roll  = alpha * (Roll  + gyroRoll * dt)  + (1.0 - alpha) * accelRoll;
  Pitch = alpha * (Pitch + gyroPitch * dt) + (1.0 - alpha) * accelPitch;


  Yaw += gyroYaw * dt;
}

float PID(float input, float target, float &prevErr, float &integral, float dt) {
  if (dt < DT_MIN) dt = DT_MIN;

  float err = target - input;
  integral += err * dt;

  if (integral > I_MAX) integral = I_MAX;
  if (integral < I_MIN) integral = I_MIN;

  float der = (err - prevErr) / dt;
  prevErr = err;

  if (der > DER_MAX) der = DER_MAX;
  if (der < -DER_MAX) der = -DER_MAX;

  float out = Kp * err + Ki * integral + Kd * der;

  if (out > 70) out = 70;
  if (out < -70) out = -70;

  return out;
}

void mpuConfigure() {
  Wire.beginTransmission(MPU);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);

  Wire.beginTransmission(MPU);
  Wire.write(0x1A);
  Wire.write(3);
  Wire.endTransmission(true);

  Wire.beginTransmission(MPU);
  Wire.write(0x19);
  Wire.write(4);
  Wire.endTransmission(true);

  Wire.beginTransmission(MPU);
  Wire.write(0x1B);
  Wire.write(0);
  Wire.endTransmission(true);

  Wire.beginTransmission(MPU);
  Wire.write(0x1C);
  Wire.write(0);
  Wire.endTransmission(true);
}

void calibrateGyro(int samples = 500) {
  long sumX = 0, sumY = 0, sumZ = 0;
  for (int i = 0; i < samples; ++i) {
    readMPU();
    sumX += GyX;
    sumY += GyY;
    sumZ += GyZ;
    delay(3);
  }
  gyroX_off = (float)sumX / samples;
  gyroY_off = (float)sumY / samples;
  gyroZ_off = (float)sumZ / samples;
}

void setup() {
  Wire.begin();
  Serial.begin(115200);

  ServoRoll.attach(4);
  ServoPitch.attach(5);


  ServoYaw.attach(6);

  mpuConfigure();
  delay(100);

  calibrateGyro(500);

  lastMicros = micros();
}

void loop() {
  readMPU();

  unsigned long now = micros();
  float dt = (now - lastMicros) / 1000000.0;
  lastMicros = now;

  computeAngles(dt);

  float outR = PID(Roll, 0.0, errR_prev, intR, dt);
  float outP = PID(Pitch, 0.0, errP_prev, intP, dt);
  // >>> AGREGADO: PID para Yaw <<<
  float outY = PID(Yaw, 0.0, errY_prev, intY, dt);

  int servoR = constrain(SERVO_CENTER - (int)round(outR), SERVO_MIN, SERVO_MAX);
  int servoP = constrain(SERVO_CENTER + (int)round(outP), SERVO_MIN, SERVO_MAX);
  int servoY = constrain(SERVO_CENTER + (int)round(outY), SERVO_MIN, SERVO_MAX);

  ServoRoll.write(servoR);
  ServoPitch.write(servoP);
  ServoYaw.write(servoY);

  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 200) {
    lastPrint = millis();
    Serial.print("Yaw:"); Serial.print(Yaw, 2);
    Serial.print(" outY:"); Serial.print(outY, 2);
    Serial.println();
  }
}
